import pandas as pd
from datetime import datetime, time as dtime
from utils.getStrikes import get_nearest_strikes
import config


class Strategy:
    """
    Short‑straddle day‑1 strategy:
      • At 13:00 on the first simulation day, sell 0.1 Call + 0.1 Put (ATM ±2 %).
      • Exit if:
          – Underlying moves ±1 % from entry   OR
          – Total PnL ≥ +500 or ≤ –500
    """

    def __init__(self, simulator):
        self.sim       = simulator
        self.entry_ts  = None         # datetime of entry
        self.entry_px  = None         # underlying price at entry
        self.call_sym  = None
        self.put_sym   = None
        self.open_qty  = 0            # qty per leg still open (+=short, –=closed)
        self.orders = []              # list of dicts to track orders
        # Trade & PnL tracking
        self.trade_log = []           # list of dicts
        self.total_pnl = 0.0
        self.call_sym, self.put_sym = None, None   
        self.open_qty = 0              # short qty (positive number)
        self.total_pnl = 0.0          # running PnL
        self.orders = []              # list of dicts to track orders
        self.trade_log = []           # list of dicts to track trades    
        # Derived — keep the first calendar day we see
        self.first_trading_day = None
        self.entry_ts = None
        self.entry_px = None    

    # ----------  EVENT HANDLERS  ---------- #
    def onMarketData(self, row: pd.Series):
        symbol = row["Symbol"]
        price = row["price"]
        size = row["size"]
        # ts = row["timestamp"]

        ts_str   = row[config.timestamp_col]
        sym      = row["Symbol"]
        price    = row[config.price_col]
        ts = row["timestamp"]

        self.orders.append({
            "symbol": symbol,
            "price": price,
            "size": size,
            "timestamp": ts,
            "side": "buy"
        })


        # Determine calendar day of first tick
        # ts = datetime.strptime(ts_str, config.time_fmt)
        if self.first_trading_day is None:
            self.first_trading_day = ts.date()

        # ENTRY LOGIC: first‑day 13:00
        if (self.entry_ts is None and
            ts.date() == self.first_trading_day and
            ts.time() >= dtime(13, 0) and
            sym == "BTCUSDT"):
            self._enter_straddle(ts, price)

        # EXIT LOGIC (only evaluate after entry)
        if self.entry_ts:
            self._check_exit_conditions(price)

        # print(f"Market Data - Symbol: {symbol}, Price: {price}, Size: {size}, Time: {ts}")


    def onTradeConfirmation(self, symbol, side, qty, px):
        """
        Called by Simulator after every fill.
        Maintain running PnL and a trade blotter.
        """
        direction = 1 if side == "SELL" else -1   # short positive, buy negative
        self.trade_log.append({
            "symbol": symbol,
            "side":   side,
            "qty":    qty,
            "price":  px,
            "ts":     datetime.now()
        })

        # Update running PnL for this trade
        delta_pnl = -direction * qty * px   # Sell adds +cash, Buy subtracts cash
        self.total_pnl += delta_pnl

    # ----------  INTERNAL HELPERS  ---------- #
    def _enter_straddle(self, ts, underlying_px):
        # Pick nearest strikes
        call_sym, put_sym = get_nearest_strikes(
            underlying_px,
            self.sim.symbols,
            config.strike_tolerance_pct
        )

        self.call_sym, self.put_sym = call_sym, put_sym
        qty = config.qty_per_leg

        # Send orders through Simulator
        self.sim.onOrder(call_sym, "SELL", qty, self.sim.currentPrice[call_sym])
        self.sim.onOrder(put_sym,  "SELL", qty, self.sim.currentPrice[put_sym])

        self.entry_ts = ts
        self.entry_px = underlying_px
        self.open_qty = qty       # short qty (positive number)
        print(f"[{ts}] Entered short straddle @ {underlying_px:.2f} "
              f"({call_sym}, {put_sym})")

    def _check_exit_conditions(self, underlying_px):
        move_pct = abs(underlying_px - self.entry_px) / self.entry_px
        if (move_pct >= config.exit_move_pct or
                self.total_pnl >= config.exit_pnl_positive or
                self.total_pnl <= config.exit_pnl_negative):
            self._exit_positions()

    def _exit_positions(self):
        if self.open_qty == 0:
            return  # already closed
        qty = self.open_qty
        self.sim.onOrder(self.call_sym, "BUY", qty,
                         self.sim.currentPrice[self.call_sym])
        self.sim.onOrder(self.put_sym,  "BUY", qty,
                         self.sim.currentPrice[self.put_sym])
        self.open_qty = 0
        print(f"[EXIT] PnL {self.total_pnl:.2f}")
